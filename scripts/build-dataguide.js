#!/usr/bin/env node

import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const LANGUAGES = ["en", "sv"];
const SOURCE_DIR = path.join(__dirname, "../src/locales/dataguide");
const OUTPUT_DIR = path.join(__dirname, "../src/locales");
const TYPES_PATH = path.join(__dirname, "../src/data-guide/items.ts");

// Ensure output directories exist
function ensureDir(dir) {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

// Read and parse a markdown file
function parseMarkdownFile(filePath) {
  try {
    const content = fs.readFileSync(filePath, "utf8");

    // Split content into title and body
    const lines = content.split("\n");
    let title = "";
    let body = "";

    // Look for the first heading as title
    const titleMatch = lines.find((line) => line.startsWith("# "));
    if (titleMatch) {
      title = titleMatch.replace("# ", "").trim();
      // Remove the title line from content
      const titleIndex = lines.indexOf(titleMatch);
      body = lines
        .slice(titleIndex + 1)
        .join("\n")
        .trim();
    } else {
      // If no title found, use the entire content as body
      body = content.trim();
    }

    return {
      title: title || "Untitled",
      content: [body.trim()],
    };
  } catch (error) {
    console.error(`Error parsing ${filePath}:`, error.message);
    return null;
  }
}

// Process all markdown files for a language
function processLanguage(lang) {
  const langDir = path.join(SOURCE_DIR, lang);

  if (!fs.existsSync(langDir)) {
    console.warn(`Directory ${langDir} does not exist, skipping...`);
    return {};
  }

  const files = fs.readdirSync(langDir).filter((file) => file.endsWith(".md"));
  const items = {};

  for (const file of files) {
    const filePath = path.join(langDir, file);
    const itemKey = path.basename(file, ".md");

    console.log(`Processing ${lang}/${file}...`);

    const parsed = parseMarkdownFile(filePath);
    if (parsed) {
      items[itemKey] = parsed;
    }
  }

  return items;
}

function generateTSTypes(validKeys) {
  const typeDef = `export type DataGuideItemId = ${validKeys.map((s) => `"${s}"`).join(" | ")};\n`;

  fs.writeFileSync(TYPES_PATH, typeDef);
}

// Main build function
function buildDataGuide() {
  console.log("Building data guide JSON files...");

  for (const lang of LANGUAGES) {
    console.log(`\nProcessing ${lang}...`);

    const items = processLanguage(lang);

    // Create the data guide structure
    const dataGuide = {
      THIS_FILE_IS_AUTOGENERATED: "DO NOT UPDATE THIS DIRECTLY",
      ...items,
    };

    // Ensure output directory exists
    const outputDir = path.join(OUTPUT_DIR, lang);
    ensureDir(outputDir);

    // Write the JSON file
    const outputPath = path.join(outputDir, "dataguideItems.json");
    fs.writeFileSync(outputPath, JSON.stringify(dataGuide, null, 2));

    console.log(
      `✓ Generated ${outputPath} with ${Object.keys(items).length} items`,
    );

    if (lang === "en") {
      const validKeys = Object.keys(items);
      generateTSTypes(validKeys);

      // output types
    }
  }

  console.log("\n✅ Data guide build complete!");
}

// Handle command line execution
if (import.meta.url === `file://${process.argv[1]}`) {
  buildDataGuide();
}

export { buildDataGuide };
